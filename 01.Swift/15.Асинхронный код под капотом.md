Это блестящий подход, поскольку понимание различий между моделями конкурентности в Swift и JS/TS — это ключ к профессионализму. Модель Swift (`async/await`) гораздо глубже интегрирована с системой типов и управлением памятью, чем модель JS (Event Loop).

Давайте разберем, как работает асинхронный код в Swift **"под капотом"**, используя сравнение с Event Loop (Циклом Событий) в JS.

---

## 25\. ⚙️ Асинхронный Код Swift "Под Капотом" (Async/Await)

### I. Введение: Ключевое Отличие от JS/TS

| Аспект           | Swift (Async/Await)                                                             | JS/TS (Event Loop/Promises)                                               |
| :--------------- | :------------------------------------------------------------------------------ | :------------------------------------------------------------------------ |
| **Основа**       | **Активное Управление Потоками (Threads)**                                      | **Пассивный Один Поток (Single Thread)**                                  |
| **Приостановка** | **Приостановка/Возобновление** потока (Cooperative Thread Pool).                | **Неблокирующее** ожидание (I/O offload).                                 |
| **Планировщик**  | **Swift Concurrency Runtime** (Среда выполнения) + **Task-Specific Executors**. | **Event Loop** (Внешний планировщик браузера/Node.js).                    |
| **Безопасность** | **Изоляция Актора** (гарантия безопасности данных).                             | **Не гарантируется** (требуется ручная синхронизация для Worker Threads). |

### II. Что происходит при вызове `async` и `await`?

Когда компилятор Swift видит функцию, помеченную как `async`, он не создает обычный код. Он преобразует функцию в машину состояний (State Machine) с точками приостановки.

#### 1\. Точка Приостановки (`await`)

Предположим, у нас есть асинхронная функция:

```swift
func fetchData() async -> Data {
    let urlData = await URLSession.shared.data(from: url) // <-- Точка 1: await
    process(urlData)
    let finalData = await processFinal(urlData)           // <-- Точка 2: await
    return finalData
}
```

- **До `await`:** Код выполняется на текущем потоке/исполнителе.
- **На `await`:** Вызывается функция, которая потенциально может занять много времени (например, сетевой запрос).
  1.  **Приостановка (Suspend):** Среда выполнения Swift (Swift Concurrency Runtime) **сохраняет текущее состояние** задачи (значения всех локальных переменных и место, где мы остановились).
  2.  **Освобождение Потока:** Поток, который выполнял `fetchData()`, **освобождается** и возвращается в **пул потоков** (Cooperative Thread Pool). Он не сидит без дела, он немедленно начинает выполнять другую готовую задачу.
  3.  **Ожидание:** Сетевой запрос выполняется внешне (обычно силами ОС, как и в JS, но без привязки к Event Loop).

#### 2\. Точка Возобновления (Resume)

- **Завершение:** Когда сетевой запрос завершается, ОС/система уведомляет Swift Concurrency Runtime.
- **Возобновление (Resume):** Runtime берет **сохраненное состояние** задачи и помещает его в **очередь** на выполнение.
- **Планирование:** Планировщик Swift (Task Executor) **подбирает освобожденный поток** из пула и **возобновляет выполнение** задачи **сразу после** того `await`, где она приостановилась.

> **Ключевой момент:** В отличие от JS, который всегда возвращается в единственный Event Loop, Swift может возобновить работу на **другом потоке**, но **гарантирует**, что код будет выполняться последовательно.

### III. Как Swift управляет Потоками? (Cooperative Thread Pool)

Вместо того чтобы разработчик напрямую работал с потоками (как в старом GCD), Swift использует **Пул Совместных Потоков (Cooperative Thread Pool)**.

1.  **Ограниченный Пул:** Система создает небольшое, оптимальное количество потоков (обычно сопоставимое с количеством ядер процессора).
2.  **Совместная Работа:** Задачи (Tasks) не закреплены за потоками жестко. Если задача на потоке сталкивается с `await` (приостановкой), поток **совместно** отдает себя в пул для выполнения других задач.
3.  **Эффективность:** Это минимизирует накладные расходы на создание и переключение потоков (Context Switching), делая конкурентность очень быстрой.

### IV. Безопасность Данных: Изоляция Актора

Вы правильно поняли, что самая большая проблема многопоточности — это гонки данных. Swift решает это с помощью **Актора (Actor)**.

#### 1\. Асинхронное Применение Мутекса

В традиционном многопоточном коде для защиты данных используется **Мутекс (Mutex)** — механизм блокировки, который заставляет другие потоки ждать, пока поток не освободит ресурс.

- **Проблема Мутекса:** Он **блокирует** поток, что плохо для производительности.

#### 2\. Решение Актора (Non-Blocking Synchronization)

Акторы не используют блокирующие мутексы в явном виде. Они используют **Асинхронную Изоляцию**.

- Когда вы вызываете **мутирующий метод** актора (например, `deposit`) извне, Swift ставит этот вызов в **очередь актора**.
- **Акторы имеют свой собственный исполнитель (Executor).** Актер берет задачи из своей очереди и выполняет их **по одной**.
- **`await` на Акторах:** Ключевое слово `await` в вызове актора говорит: "Подожди своей очереди, чтобы твоя задача была выполнена безопасно, когда актор свободен."

> **Сравнение:**
>
> - **Мутекс (Старый):** "Эй, я здесь\! **Блокирую** этот замок, пока не закончу. Все остальные **стоят** и ждут." (Плохая масштабируемость)
> - **Актер (Новый):** "Эй, я хочу внести $100. Вот моя **задача**. Планировщик, **добавь** это в очередь актора. Я буду **ждать** (но мой поток свободен для другой работы), пока актер не выполнит эту задачу." (Высокая масштабируемость)

### V. Сравнение с Event Loop в JS/TS

- **JS/TS:** Конкурентность — это в основном **управление асинхронными вызовами ввода/вывода (I/O)**. Сам код приложения всегда выполняется в **одном потоке**. Event Loop просто управляет, когда _callback'и_ попадают в очередь на выполнение. Это просто, но не позволяет эффективно использовать многоядерные процессоры для CPU-bound задач (кроме Worker Threads).
- **Swift:** Конкурентность — это **полноценное использование многоядерности** (CPU-bound и I/O-bound). Swift Runtime активно управляет пулом потоков, переключая задачи и гарантируя безопасность данных через изоляцию акторов.

**Итог:** Асинхронный код в Swift работает через трансформацию функций в **машины состояний**, управляемые **Task Executor** и **Cooperative Thread Pool**. Это позволяет писать высокопроизводительный, многопоточный код, который благодаря **Акторам** является одновременно типобезопасным и потокобезопасным.
